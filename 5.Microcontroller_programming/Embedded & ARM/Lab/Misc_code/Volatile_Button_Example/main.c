/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/

#include<stdint.h>

int main(void)
{
	uint32_t  volatile *const pClkCtrlReg =   (uint32_t*)0x40023830;
	uint32_t  volatile *const pPortDModeReg = (uint32_t*)0x40020C00;
	uint32_t  volatile *const pPortDOutReg =  (uint32_t*)0x40020C14;

	uint32_t volatile *const pPortAModeReg = (uint32_t*)0x40020000;
	uint32_t const volatile *const pPortAInReg =   (uint32_t*)0x40020010;


	//enable the clock for GPOID , GPIOA peripherals in the AHB1ENR
	*pClkCtrlReg |= ( 1 << 3);
	*pClkCtrlReg |= ( 1 << 0);

    //configuring PD12 as output
	*pPortDModeReg &= ~( 3 << 24);
	//make 24th bit position as 1 (SET)
	*pPortDModeReg |= ( 1 << 24);

	//Configure PA0 as input mode (GPIOA MODE REGISTER)
	*pPortAModeReg &= ~(3 << 0);

	while(1)
	{
		//read the pin status of the pin PA0 (GPIOA INPUT DATA REGISTER)
		uint8_t  pinStatus = (uint8_t)(*pPortAInReg & 0x1); //zero out all other bits except bit 0
		
/* So, that is with our pin_read example code and we know that, 
this application actually breaks when we activate the O3 optimization level.
So, when we were debugging this through disassembly we came to know that, the compiler has generated instructions
where this code is executed only once. So, processor is not reading this memory address again and again
for every iteration in order to fetch the new value.
So, that's because a compiler has done an optimization on this address. The compiler has assumed that
the data at this memory location will never change. So,
but now we have to tell the compiler that the data at this address can change unexpectedly.
So, that's why, lets change the declaration of this pointer.
So, here we have to mention volatile. So now, compiler will not optimize any read and write
operations performed on this pointer. So, that would solve this issue,
but I said one thing while explaining the theory that, whenever you are accessing memory mapped peripheral
registers use volatile generously.
*/
		if(pinStatus){
			//turn on the LED
			*pPortDOutReg |= ( 1 << 12);
		}else{
			//turn off the LED
			*pPortDOutReg &= ~( 1 << 12);
		}
	}

}
